<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weiqi (Go) Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* Prevents double-tap zoom on mobile */
        }
        .board-container {
            width: 95vw;
            max-width: 80vh; /* Board size is responsive, capped by viewport height */
            margin: auto;
        }
        canvas {
            background-color: #dcb35c;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1), 0 6px 6px rgba(0,0,0,0.15);
            border-radius: 1rem;
            cursor: pointer;
        }
        .btn-action {
            transition: all 0.2s ease-in-out;
        }
        .btn-action:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .btn-action:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .turn-indicator {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            display: inline-block;
            vertical-align: middle;
        }
        .message-modal {
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl mx-auto">
        <h1 class="text-4xl font-bold text-center text-gray-700 mb-4">Weiqi (Go)</h1>

        <!-- Game Info Panel -->
        <div class="flex justify-around items-center bg-white rounded-xl shadow-md p-4 mb-4">
            <div class="text-center">
                <h2 class="text-lg font-semibold">Player: Black</h2>
                <p class="text-xl font-bold">Captures: <span id="black-captures">0</span></p>
            </div>
            <div class="text-center">
                <h2 class="text-lg font-semibold">Current Turn</h2>
                <div id="turn-indicator" class="turn-indicator bg-black mx-auto mt-1"></div>
            </div>
            <div class="text-center">
                <h2 class="text-lg font-semibold">Player: White</h2>
                <p class="text-xl font-bold">Captures: <span id="white-captures">0</span></p>
            </div>
        </div>

        <!-- Board -->
        <div class="board-container aspect-square">
            <canvas id="go-board"></canvas>
        </div>

        <!-- Controls -->
        <div class="flex justify-center items-center space-x-4 mt-4">
            <button id="pass-btn" class="btn-action bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg shadow-md">Pass Turn</button>
            <button id="reset-btn" class="btn-action bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-lg shadow-md">Reset Game</button>
        </div>
    </div>

    <!-- Message Modal -->
    <div id="message-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 opacity-0 pointer-events-none">
        <div id="message-box" class="bg-white rounded-lg shadow-2xl p-6 max-w-sm text-center transform scale-95">
            <p id="message-text" class="text-lg font-medium"></p>
            <button id="message-close-btn" class="mt-4 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">Close</button>
        </div>
    </div>


    <script>
        const canvas = document.getElementById('go-board');
        const ctx = canvas.getContext('2d');

        // --- Game Constants ---
        const BOARD_SIZE = 19;
        const HOSHI_POINTS = [ // Star points for a 19x19 board
            {x: 3, y: 3}, {x: 9, y: 3}, {x: 15, y: 3},
            {x: 3, y: 9}, {x: 9, y: 9}, {x: 15, y: 9},
            {x: 3, y: 15}, {x: 9, y: 15}, {x: 15, y: 15}
        ];

        // --- Game State Variables ---
        let board;
        let currentPlayer;
        let capturedStones;
        let consecutivePasses;
        let boardHistory; // For Ko rule detection
        let isGameOver;

        // --- UI Elements ---
        const blackCapturesEl = document.getElementById('black-captures');
        const whiteCapturesEl = document.getElementById('white-captures');
        const turnIndicatorEl = document.getElementById('turn-indicator');
        const passBtn = document.getElementById('pass-btn');
        const resetBtn = document.getElementById('reset-btn');
        const messageModal = document.getElementById('message-modal');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const messageCloseBtn = document.getElementById('message-close-btn');
        
        // --- Sizing and Drawing Variables ---
        let GRID_SIZE;
        let STONE_RADIUS;

        /**
         * Initializes or resets the game state.
         */
        function initGame() {
            board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0));
            currentPlayer = 1; // 1 for Black, 2 for White
            capturedStones = { 1: 0, 2: 0 };
            consecutivePasses = 0;
            boardHistory = [];
            isGameOver = false;
            
            updateInfoPanel();
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }
        
        /**
         * Adjusts canvas size to fit the container and redraws the board.
         */
        function resizeCanvas() {
            const containerSize = canvas.parentElement.clientWidth;
            canvas.width = containerSize;
            canvas.height = containerSize;
            GRID_SIZE = canvas.width / (BOARD_SIZE + 1);
            STONE_RADIUS = GRID_SIZE * 0.45;
            drawBoard();
        }

        /**
         * Draws the entire Go board, including grid lines, hoshi points, and stones.
         */
        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid lines
            ctx.strokeStyle = '#6b4f2c';
            ctx.lineWidth = 1;
            for (let i = 0; i < BOARD_SIZE; i++) {
                const pos = (i + 1) * GRID_SIZE;
                // Vertical lines
                ctx.beginPath();
                ctx.moveTo(pos, GRID_SIZE);
                ctx.lineTo(pos, canvas.height - GRID_SIZE);
                ctx.stroke();
                // Horizontal lines
                ctx.beginPath();
                ctx.moveTo(GRID_SIZE, pos);
                ctx.lineTo(canvas.width - GRID_SIZE, pos);
                ctx.stroke();
            }

            // Draw hoshi (star) points
            ctx.fillStyle = '#6b4f2c';
            HOSHI_POINTS.forEach(p => {
                ctx.beginPath();
                ctx.arc((p.x + 1) * GRID_SIZE, (p.y + 1) * GRID_SIZE, GRID_SIZE * 0.1, 0, 2 * Math.PI);
                ctx.fill();
            });

            // Draw stones
            for (let y = 0; y < BOARD_SIZE; y++) {
                for (let x = 0; x < BOARD_SIZE; x++) {
                    if (board[y][x] !== 0) {
                        drawStone(x, y, board[y][x]);
                    }
                }
            }
        }

        /**
         * Draws a single stone on the board with a subtle gradient for a 3D effect.
         * @param {number} x - The x-coordinate on the board (0-18).
         * @param {number} y - The y-coordinate on the board (0-18).
         * @param {number} player - The player who owns the stone (1 for Black, 2 for White).
         */
        function drawStone(x, y, player) {
            const canvasX = (x + 1) * GRID_SIZE;
            const canvasY = (y + 1) * GRID_SIZE;
            
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, STONE_RADIUS, 0, 2 * Math.PI);

            const gradient = ctx.createRadialGradient(
                canvasX - STONE_RADIUS * 0.3, canvasY - STONE_RADIUS * 0.3, STONE_RADIUS * 0.1,
                canvasX, canvasY, STONE_RADIUS
            );

            if (player === 1) { // Black stone
                gradient.addColorStop(0, '#555');
                gradient.addColorStop(1, '#000');
            } else { // White stone
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(1, '#ccc');
            }
            
            ctx.fillStyle = gradient;
            ctx.fill();
        }

        /**
         * Handles a click event on the canvas, attempting to place a stone.
         * @param {MouseEvent} event - The click event.
         */
        function handleBoardClick(event) {
            if (isGameOver) {
                showMessage("The game is over. Please reset to play again.");
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            const x = Math.round(clickX / GRID_SIZE) - 1;
            const y = Math.round(clickY / GRID_SIZE) - 1;

            if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE) return;

            placeStone(x, y);
        }

        /**
         * The core logic for placing a stone and processing the consequences.
         * @param {number} x - The x-coordinate for the move.
         * @param {number} y - The y-coordinate for the move.
         */
        function placeStone(x, y) {
            // 1. Check if the intersection is already occupied
            if (board[y][x] !== 0) {
                showMessage("This position is already taken.");
                return;
            }

            // --- Simulate the move to check for legality ---
            const tempBoard = board.map(row => [...row]);
            tempBoard[y][x] = currentPlayer;
            let capturedInMove = 0;

            // 2. Check for captures of opponent stones
            const opponent = currentPlayer === 1 ? 2 : 1;
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (tempBoard[i][j] === opponent) {
                        const group = findGroup(j, i, opponent, tempBoard);
                        if (group.liberties === 0) {
                            capturedInMove += group.stones.length;
                            group.stones.forEach(stone => {
                                tempBoard[stone.y][stone.x] = 0;
                            });
                        }
                    }
                }
            }

            // 3. Check for suicide
            const ownGroup = findGroup(x, y, currentPlayer, tempBoard);
            if (ownGroup.liberties === 0 && capturedInMove === 0) {
                showMessage("Illegal move: Suicide is not allowed.");
                return;
            }

            // 4. Check for Ko (reverting to the immediate previous board state)
            const boardState = JSON.stringify(tempBoard);
            if (boardHistory.length > 0 && boardHistory[boardHistory.length - 1] === boardState) {
                showMessage("Illegal move: This move violates the Ko rule.");
                return;
            }

            // --- If all checks pass, commit the move ---
            board = tempBoard;
            capturedStones[currentPlayer] += capturedInMove;
            
            // Save board state for Ko rule
            boardHistory.push(JSON.stringify(board));

            // Switch player and update UI
            switchPlayer();
            consecutivePasses = 0;
            drawBoard();
            updateInfoPanel();
        }

        /**
         * Finds a group of connected stones and counts its liberties.
         * @param {number} startX - The starting x-coordinate of the group.
         * @param {number} startY - The starting y-coordinate of the group.
         * @param {number} player - The player who owns the group.
         * @param {Array<Array<number>>} currentBoard - The board state to check against.
         * @returns {{stones: Array<{x, y}>, liberties: number}} - An object containing the stones in the group and their total liberties.
         */
        function findGroup(startX, startY, player, currentBoard) {
            const stones = [];
            const liberties = new Set();
            const toCheck = [{x: startX, y: startY}];
            const checked = new Set();
            checked.add(`${startX},${startY}`);

            while (toCheck.length > 0) {
                const {x, y} = toCheck.pop();
                stones.push({x, y});

                const neighbors = [{dx: 0, dy: 1}, {dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: -1, dy: 0}];
                neighbors.forEach(n => {
                    const nx = x + n.dx;
                    const ny = y + n.dy;

                    if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
                        const neighborKey = `${nx},${ny}`;
                        if (checked.has(neighborKey)) return;

                        if (currentBoard[ny][nx] === 0) {
                            liberties.add(neighborKey);
                        } else if (currentBoard[ny][nx] === player) {
                            checked.add(neighborKey);
                            toCheck.push({x: nx, y: ny});
                        }
                    }
                });
            }
            return { stones, liberties: liberties.size };
        }

        /**
         * Switches the current player.
         */
        function switchPlayer() {
            currentPlayer = currentPlayer === 1 ? 2 : 1;
        }

        /**
         * Updates the information panel with current captures and turn indicator.
         */
        function updateInfoPanel() {
            blackCapturesEl.textContent = capturedStones[1];
            whiteCapturesEl.textContent = capturedStones[2];
            turnIndicatorEl.className = 'turn-indicator mx-auto mt-1'; // Reset classes
            if (currentPlayer === 1) {
                turnIndicatorEl.classList.add('bg-black');
            } else {
                turnIndicatorEl.classList.add('bg-white', 'border', 'border-gray-400');
            }
        }
        
        /**
         * Handles a player passing their turn. Ends the game if both pass consecutively.
         */
        function handlePass() {
            if (isGameOver) {
                showMessage("The game is over. Please reset to play again.");
                return;
            }
            consecutivePasses++;
            if (consecutivePasses >= 2) {
                endGame();
            } else {
                switchPlayer();
                updateInfoPanel();
                showMessage(`Player ${currentPlayer === 1 ? 'White' : 'Black'} passed. It's now Player ${currentPlayer === 1 ? 'Black' : 'White'}'s turn.`);
            }
        }

        /**
         * Ends the game and displays a message.
         * Note: Does not include territory scoring for simplicity.
         */
        function endGame() {
            isGameOver = true;
            // A simple win condition based on captures. Real Go scoring is much more complex.
            let winnerMessage;
            if (capturedStones[1] > capturedStones[2]) {
                winnerMessage = "Black wins by captures!";
            } else if (capturedStones[2] > capturedStones[1]) {
                winnerMessage = "White wins by captures!";
            } else {
                winnerMessage = "It's a tie based on captures!";
            }
            showMessage(`Game Over! Both players passed. ${winnerMessage}`);
        }

        /**
         * Displays a message in a modal dialog.
         * @param {string} text - The message to display.
         */
        function showMessage(text) {
            messageText.textContent = text;
            messageModal.classList.remove('opacity-0', 'pointer-events-none');
            messageBox.classList.remove('scale-95');
            messageModal.classList.add('opacity-100');
            messageBox.classList.add('scale-100');
        }

        /**
         * Hides the message modal.
         */
        function hideMessage() {
            messageModal.classList.add('opacity-0');
            messageBox.classList.add('scale-95');
            setTimeout(() => {
                messageModal.classList.add('pointer-events-none');
            }, 300); // Wait for transition to finish
        }

        // --- Event Listeners ---
        canvas.addEventListener('click', handleBoardClick);
        passBtn.addEventListener('click', handlePass);
        resetBtn.addEventListener('click', () => {
            if (confirm("Are you sure you want to reset the game?")) {
                initGame();
            }
        });
        messageCloseBtn.addEventListener('click', hideMessage);
        messageModal.addEventListener('click', (e) => {
            if (e.target === messageModal) {
                hideMessage();
            }
        });


        // --- Start the Game ---
        initGame();

    </script>
</body>
</html>